<a href="https://jq.qq.com/?_wv=1027&k=5bjm2ib">点击加入群聊【Pig软件交流群】</a>  
<a href="https://weibo.com/p/1005057397275559/home?from=page_100505&mod=TAB&is_all=1#place">点击查看新浪微博</a>  
<a href="http://39.108.219.27:8080/apps/ppt20200310.html">PIG演示视频及文稿</a>  

<h1>什么是PIG</h1>
PIG是一种面向状态机编程的编程语言，它不同于其他语言，它是图形化的，通过图、节点、箭头就可以完成程序的逻辑，极大的减少代码量，提高开发效率，并降低了编程门槛，即使没有学习过编程的人也可以快速掌握，轻松实现多线程、web、爬虫等各种复杂的开发。

<h1>第一章 快速入门</h1>  
## 1.1 环境配置与编写简单的面向状态机程序  
&nbsp;&nbsp;&nbsp;&nbsp;学习编程，动手实践是最好的方式。在这一节中将要配置好程序环境（这很简单），并且编写一个简单的程序来熟悉IDE以及开始面向状态机的程序设计！  

**1.1.1 配置环境**  
下载并解压test.rar，并运行test.exe  
注意：尽量不要在系统盘，可能会因为权限不能成功运行  
![运行test.exe](https://tva1.sinaimg.cn/large/006tNbRwgy1gbn2nmplenj309m03hwec.jpg)  

运行以后会出现黑窗口，如下图  
![IDE运行结果](https://tva1.sinaimg.cn/large/006tNbRwgy1gbn2tbxuzfj30d9020glg.jpg)  

运行成功之后会自动使用默认浏览器打开IDE，如果没有，可以手动使用浏览器进入  
http://39.108.219.27:8080/ide/runner  

会看到以下界面
![运行视图](https://s2.ax1x.com/2020/02/06/1c1Nng.png)  
点击开发视图进入开发页面，准备开始我们的第一个面向状态机的程序

**1.1.2 第一个程序**  
在管理树的根右键，选择创建子资源  
![avatar](https://tva1.sinaimg.cn/large/006tNbRwgy1gbn1rwhaywj30am09qdg9.jpg)

输入名称，最后，点击确定  
注意：使用回车会导致页面刷新，从而创建失败
![1c1hNR.md.png](https://s2.ax1x.com/2020/02/06/1c1hNR.md.png)

对着刚创建的资源相同的步骤创建图，并对创建的图右键，选择编辑图  
![1c3sIA.png](https://s2.ax1x.com/2020/02/07/1c3sIA.png)  

好了，现在我们可以开始在中间的编辑窗口进行编程了  
右键编辑窗口空白区域，创建节点  
![1c3Iaj.png](https://s2.ax1x.com/2020/02/07/1c3Iaj.png)  
再来一次，创建两个节点  
点选其中一个节点，在右侧属性面板，命名为print  
![1c8Zee.png](https://s2.ax1x.com/2020/02/07/1c8Zee.png)  
拖动state到print上，就可以生成一条线连接两个节点  
点击state节点，将下方的选项卡切换到“代码”，并在其中写上  
```
string s = "你好，SOP!";
```  
右键state节点，点击运行，讲下方选项卡切换到“消息”，就可以看到输出信息了  
![1cy0pT.png](https://s2.ax1x.com/2020/02/07/1cy0pT.png)  
第一个简单的面向状态机程序完成！  

## 1.2 本地运行IDE  
在没有网络的情况下，IDE也可以本地运行，只需要将IDE的压缩包解压到website目录下，并对配置文件进行修改即可。  
website目录下应该是这样  
![3DzMUe.png](https://s2.ax1x.com/2020/02/28/3DzMUe.png)  
config.json文件是这样  
![3Dzr2n.png](https://s2.ax1x.com/2020/02/28/3Dzr2n.png)  
也可以是
```
"serverAddress":""
```  
这样的话地址和端口都是默认，与访问页面的地址和端口相同。
接下来访问你的serverAddress后面加上```/ide/editor```
比如```http://localhost:2000/ide/editor```就能看到本地运行的IDE了。
注意：此处如果使用配置的地址访问没有内容，请清理缓存重新访问，可能是因为使用了缓存，没有加载配置。

## 1.3 初识输出  
SOP使用print图进行输出，有以下几种方式

**1.3.1 添加到图中**  
按照1.1.2中的方法创建一个图，在其中创建节点，之后在左侧的管理树中的architecture资源下对print右键选择“添加到”  
![3STuGR.png](https://s2.ax1x.com/2020/02/16/3STuGR.png)  
print图已经添加到了自己创建的图中，但是并不整齐，在编辑窗口空白处右键选择自动布局图，这下就很整齐了！  
![3S7wtJ.png](https://s2.ax1x.com/2020/02/16/3S7wtJ.png)  
就可以进行建箭头，写代码等操作。但是，需要注意这里是两张图，同一张图内的节点共用数据；跨图的节点数据并不共享，所以需要选中箭头，下方切换到映射表选项卡，并建立映射
![3SO2YF.md.png](https://s2.ax1x.com/2020/02/16/3SO2YF.md.png)  
其中“源”是test图中state节点中的变量名  
![3SXcnI.png](https://s2.ax1x.com/2020/02/16/3SXcnI.png)  
目标是指经过映射后的变量名，图中所示的就是将state节点中的变量s传递给print，并命名为printString。来看一下输出结果
![3Sv4yj.png](https://s2.ax1x.com/2020/02/16/3Sv4yj.png)  

**1.3.2 代码中输出**  
这种方式就不需要创建节点，和添加print图，直接在代码中使用print就可以达到效果  
![3pFGmF.png](https://s2.ax1x.com/2020/02/16/3pFGmF.png)  
结果如下  
![3pkVc6.png](https://s2.ax1x.com/2020/02/16/3pkVc6.png)

**1.3.3 创建print节点**  
这种方法就是1.1.2中的方法，在图中创建一个命名为print的节点，代码缺省，就可以使用这个节点进行输出，因为编译器在没有代码的情况下会根据这个节点的名字运行默认代码。

## 1.4 关于输入
在SOP中，输入暂时有两种方式。其一是通过前端发送请求来实现输入；其二是通过“用例”来无人值守自动运行。暂时还不支持类似C语言中scanf的方式，因为它会中断软件运行，实际上应该是debug的机制。  
这一节主要介绍使用“用例”进行输入，而另一种方式在后面的章节会详细介绍。

建好一个图以及一个节点，其中编写如下代码
```
int b = 1;b += a;print(b);
```  
![3pdwC9.png](https://s2.ax1x.com/2020/02/16/3pdwC9.png)  
可以看到，其中并没有变量a，结果却是3。这是怎么回事呢？  
![3pD9qP.png](https://s2.ax1x.com/2020/02/16/3pD9qP.png)
这个就是“用例”的输入方法输入了变量a  
![3psYHx.png](https://s2.ax1x.com/2020/02/16/3psYHx.png)  
变量a的值是2，所以b的值就是1+2，就是输出的结果了


## 1.5 关于注释  
SOP的注释方式有行注释和段注释  
```
//这是行注释，以双斜杠开头，之后的此行内容都会被注释掉
```  
```
/*这是段注释，在斜杠星和星斜杠中间的内容都会被注释掉，可以是一行，也可以是很多行*/
```  
注释掉的内容不会被执行，我们用1.3中例子来看一看  
![3p68Tx.png](https://s2.ax1x.com/2020/02/16/3p68Tx.png)  
![3p6Jk6.png](https://s2.ax1x.com/2020/02/16/3p6Jk6.png)  
使用两种方式注释了第二行的内容，输出的结果都是1，这一行的内容被跳过了  
注意：注释是不能嵌套的  
![3p6R1g.png](https://s2.ax1x.com/2020/02/16/3p6R1g.png)  


<h1>第二章 数据类型</h1>
在SOP中暂时有7种数据类型，这一章将逐一介绍这7种数据类型。  
在定义变量的时候都采用`数据类型 变量名;`的方式  
例如定义一个整型变量a写成 `int a;`在需要赋初值的时候，我们习惯的写成`int a = 1;`这样就得到一个值为1的整型变量a，此方法对以下的7种数据类型都是通用的，只需要按照这个格式就可以完成变量的定义。
## 2.1 整型  
整型就是不带小数点的数，整型在编程中可以写作“int”，也可以使用中文“整型”  
![3P6xoR.png](https://s2.ax1x.com/2020/02/17/3P6xoR.png)  
这个例子的输出结果就是  
```
a = 111
b = 222
c = 333
```  
第一行就是定义一个整型的变量a，并赋初值111，第三行就是定义了一个整型变量c，但是没有赋初值，在没有赋初值的情况下，它的值为0。第四行就给变量c重新赋值，结果是a加上b的值。

## 2.2 小数和浮点  
小数与浮点，是有了小数位的数，浮点写作“float”，小数写作“double”。当然也可以使用它们的中文名字，在SOP中float和double并没有区别。    
![3PWCAH.png](https://s2.ax1x.com/2020/02/17/3PWCAH.png)  
这个例子的输出结果为  
```
f = 1.123456
d = 1.654321
sum = 2.777777
```  

## 2.3 字符串  
```
hello, SOP!
```
这是一个字符串，顾名思义，字符串就是由字符一个接一个组成的一个串状结构，字符可以是a～z的英文字母，可以是0～9的数字，还可以是标点符号、换行符、制表符等特殊符号。  
有了字符串，SOP还提供了对字符串进行操作的方法  

* replace(src, from, to)
* del(src, start, len)
* mid(src, start, len)
* left(src, left)
* find(src, find, start=0)

下面来看一个例子  
![3ZlS2j.png](https://s2.ax1x.com/2020/02/20/3ZlS2j.png)  
这个例子里定义了一个字符串s，并赋值“qqqwwweee”，然后将从第3个字符开始，删除3个字符，最后的结果就为“qqqeee”  
![3ZlWyn.png](https://s2.ax1x.com/2020/02/20/3ZlWyn.png)  

## 2.4 指针
在C/C++中，指针可谓是灵魂了，SOP保留了指针，我们来看看指针怎么用  
![3Z1RhD.png](https://s2.ax1x.com/2020/02/20/3Z1RhD.png)  
我们将2.3中的字符串例子稍加改造，使用了一个指针p1，来指向原始的字符串s，接下来，通过p1来操作，在修改之前和修改之后分别赋值给s2、s3，那这样的输出是什么呢？  
![3Z1qN8.png](https://s2.ax1x.com/2020/02/20/3Z1qN8.png)  
s变了，s2还是和原始字符串一样，s3也变了，这就说明，指针，其实就是一个“标签”，用来贴在原始字符串的头上，它指向的是原始字符串的内存区域，它自身并没有字符串s的值，所以，如果s改变，那指针输出的结果也会改变。  

## 2.5 结构体
结构体(struct)是什么？结构体就是一个大收纳箱，里面还有很多小空间，而有多少个小空间，那个我们自己去定，定义一个结构体的过程，就是我们自己DIY收纳箱的过程，来举个栗子  
![3ZsTzR.png](https://s2.ax1x.com/2020/02/20/3ZsTzR.png)  
这里我们定义了一个结构体b，这个是大箱子，然后我们要给b里面划分空间，先划分一个c，这个空间是用来存小数的；再来一个d，用来存整数；最后来一个e，用来存我们刚刚学会的字符串。并且都给它们放一些值进去，运行一下。  
![3ZgxBt.png](https://s2.ax1x.com/2020/02/20/3ZgxBt.png)  
输出到结果里，值都一一对应，显示了出来，如果要对其中某个小空间的值进行操作，就使用```结构体名.子名```，但是注意，这个地方我们跨图了，两张图之间不共享数据，需要使用箭头来映射数据  
![3Z2F3Q.png](https://s2.ax1x.com/2020/02/20/3Z2F3Q.png)  
这里使用了解构的模式来映射，会将结构体里的数据解析出来，再解构的时候“目标”处不起作用。

## 2.6 数组
数组数组，顾名思义，就是由数构成的一个组，数组使用“[]”进行操作，来看个例子  
![3Z86JO.png](https://s2.ax1x.com/2020/02/20/3Z86JO.png)  
这个例子中我们定义了一个数组arr，然后给数组的第0位赋值1、第1位赋值2、第100位赋值3，参考下图  
![8pCuvj.png](https://s2.ax1x.com/2020/03/09/8pCuvj.png)  
就是这样一个数组，给其中的三个进行了赋值  
那输出结果显而易见了   
![3ZG3Xd.png](https://s2.ax1x.com/2020/02/20/3ZG3Xd.png)  
另外，还可以使用getcount()来获取数组的大小

## 2.7 二进制对象  
二进制对象(blob)是一个特殊的数组，每一个元素都是只有一个字节的整数，也就是说最大值只有255，并且，区别于数组的是它是一段连续的内存空间。我们在2.6数组中的例子，我们只对第0、1、100位进行了赋值，数组实际也就只有这三个元素，但是在blob中，如果我们这样做，中间的内存是存在的，看下图  
![3mVurT.png](https://s2.ax1x.com/2020/02/20/3mVurT.png)  
使用setsize方法给b设置了大小，并对第0个和第9个元素进行赋值，结果是  
![3mZ3m8.png](https://s2.ax1x.com/2020/02/20/3mZ3m8.png)  
可以看到，第0个和第9个元素确实是我们赋的值，中间没有赋值的内存区域却是存在的，值是在我们使用这段内存之前存在里面的值。  
对blob还可以使用getsize()，或者sizeof(blob)来获得空间大小。  

## 2.8 动态声明
PIG支持动态声明，什么是动态声明呢？就是不事先声明变量，在使用的时候无需声明，PIG可以根据赋的值进行自动声明，来看一个例子  
![8NcNoF.png](https://s1.ax1x.com/2020/03/17/8NcNoF.png)  
这个例子中“var”变量是手动声明的，而“dynamicVar”是没有声明直接赋值，并对它们通过节点内和跨图两种方式进行了打印，结果如下  
![8NcOYQ.png](https://s1.ax1x.com/2020/03/17/8NcOYQ.png)  
可以看到，在节点内的输出都是成功的，但是跨图的时候，却只输出了手动声明的“var”，这说明PIG可以动态变量，但是**作用范围只在它存在的节点内**。

<h1>第三章 控制结构</h1>
编程有两点需要明确，一是逻辑，二是计算。而逻辑怎么来体现，就需要用到结构控制语句，分为判断、选择和循环，下面一一来看下。  

## 3.1 判断  
在SOP中判断只有if语句，用于判断一个条件为真时，应该执行的操作。SOP只支持if，不支持else。但是除了单分支if，还支持多分枝，if可以进行嵌套，用于判断一个事件多种情况的时候。  
![3ZjE7T.png](https://s2.ax1x.com/2020/02/20/3ZjE7T.png)  
这个例子中使用了randInt()，它的作用是产生一个0到传进去的数之间的随机数，这个例子中传进去的值是100，产生的就是[0,100]的一个整数。还有另外一个rand(),产生的是[0,1)的随机浮点数。  
拿到这个数之后就进行判断，如果大于50就输出“a>50“，如果小于等于50，则输出“a <= 50”，两者间只能有一个输出。  
![3ZxxAK.png](https://s2.ax1x.com/2020/02/20/3ZxxAK.png)  
来看看结果，a的值是73，输出的是大于50，是正确的。  

## 3.2 return  
通过上面的例子我们都知道了，SOP是在不同节点之间进行的，那么如果出现一个状态需要根据不同的条件转移到不同的状态，那怎么办呢，就要使用return语句来进行选择路由了。  
return语句只能返回整数，缺省的话默认返回0，根据箭头的期望值来选择路径，来看下面这个例子  
![3eCXF0.png](https://s2.ax1x.com/2020/02/20/3eCXF0.png)  
对3.1的例子进行改造，将两个输出放在两个节点里  
节点1的代码是  
```
print("a <= 50");
```  
节点0的代码是  
```
print("a > 50");
```  
根据随机数来选择走哪条路径，可以看到箭头上的数字，这是箭头的期望值，当return 1时，就往期望值为1的箭头走，结果如下  
![3esCTO.png](https://s2.ax1x.com/2020/02/20/3esCTO.png)  


## 3.3 循环
在SOP中，为了安全可控，不提供for或while等循环语句，如果需要使用循环的时候，要用节点之间循环的箭头来实现循环  
![3e4uxU.png](https://s2.ax1x.com/2020/02/20/3e4uxU.png)  
这个例子中“start”节点中定义了一个整型a，代码为  
```
int a = 0;
```  
节点“1”中代码为  
```
a++;
```  
a++是自增运算，相当于a+=1或a=a+1。  
图中可以看到节点“0”的代码，做出一个判断，并使用了return语句选择路由，从而实现循环。最后的输出结果当然就为10了。  
![3eTew4.png](https://s2.ax1x.com/2020/02/20/3eTew4.png)  
这个例子还可以稍加改造，使用节点的自连接箭头将0和1合并在一起  
![3eT410.png](https://s2.ax1x.com/2020/02/20/3eT410.png)  

<h1>第四章 箭头</h1>
## 4.1 push和pop
之前我们使用过了箭头，箭头就是表示状态的转移，但是在跨图使用的时候，属性面板会有类型选项，其中可选push和pop，那这个是什么意思呢？  
![33upvT.png](https://s2.ax1x.com/2020/02/23/33upvT.png)  
push和pop只有在跨图的时候才需要，我们来看个例子  
![38taT0.png](https://s2.ax1x.com/2020/02/24/38taT0.png)  
这是一个从数据库里查询出所有数据并且打印出来的过程，我们已经插入了一条数据  
![38NWuj.png](https://s2.ax1x.com/2020/02/24/38NWuj.png)  
startList节点开始，是一个跨图的箭头，需要传入一个resTypeId，所以在映射表内加入这个映射  
![38UaGT.png](https://s2.ax1x.com/2020/02/24/38UaGT.png)  
既然是查询数据，那肯定有一个查询结果，所以在结束以后箭头返回了原图，并将查询到的数据映射了回来  
![38awkt.png](https://s2.ax1x.com/2020/02/24/38awkt.png)  
特别要注意，“startList”节点进入到“Listdata_copy”图的箭头是push类型，而查询结束以后的箭头是pop类型  
![38aht0.png](https://s2.ax1x.com/2020/02/24/38aht0.png)  
这是因为需要“返回原图”，每一个pop箭头，都会和一个push箭头相对应。最后的输出结果如下  
![38dPnH.png](https://s2.ax1x.com/2020/02/24/38dPnH.png)  

## 4.2 类型  
![3G1W5D.png](https://s2.ax1x.com/2020/02/24/3G1W5D.png)
在跨图的时候，箭头有四种类型可以选择，分别是“默认”、“解构”、“foreach”、“结构化”，分别来看下  
### 4.2.1 默认  
创建的箭头默认的就是该类型，这种类型的箭头，会将映射的数据拷贝一份至目标，这里请注意，是拷贝，也就是说原本的数据和目标数据是两份数据，改变目标数据并不会导致源数据被改变，下面我们来看个例子  
![3Glxnx.png](https://s2.ax1x.com/2020/02/24/3Glxnx.png)  
这个例子从test图的state节点开始运行，这里有一个和别的编程语言不一样的地方，从开始有两个箭头，且两个箭头的期望值都是一样的，在PIG里就是同时运行，“outTest”节点里的代码是  
```
sleep(3000);
print(a);
```  
sleep是什么？sleep就是睡眠，中间的参数3000，是指3000毫秒，也就是3秒，让程序睡眠3秒，之后再执行print。而另一边呢testHelp图的state节点，里面很简单```b+=1;```，箭头就是将a映射为b，使用默认类型。运行一下  
![3G8ctO.png](https://s2.ax1x.com/2020/02/24/3G8ctO.png)  
可以看到结果先输出了```b=2```在过了接近3秒再输出的1，也就是说在testHelp图的state节点将映射过来的值改变了以后，源数据并没有改变！它们是两份数据。

### 4.2.2 解构  
解构类型的箭头用于传递结构体需要将结构体中的元素分离出来的时候使用，来看个例子  
![3GJ1oV.png](https://s2.ax1x.com/2020/02/24/3GJ1oV.png)  
![3GJUy9.png](https://s2.ax1x.com/2020/02/24/3GJUy9.png)  
当我们直接这样输出一个结构体的时候，输出的依然是一个整体，我们看看使用解构类型的箭头会有什么效果  
![3GJhwt.png](https://s2.ax1x.com/2020/02/24/3GJhwt.png)  
在使用解构时，“目标”就不再起作用了，因此这项可以为空。  
![3GJjwq.png](https://s2.ax1x.com/2020/02/24/3GJjwq.png)  
此时的输出就是3个，将一整个结构体中的元素都分离出来，单独成为一个变量，这就是解构的作用。

### 4.2.3 foreach  
foreach类型用于传递数组，并将数组中的所有元素分离出来，这样看起来有点像解构，但是并不是一样的，foreach的强大在于会创建多个线程，具体怎样我们来看个例子  
![3GaeDH.png](https://s2.ax1x.com/2020/02/24/3GaeDH.png)  
箭头类型是foreach  
![3Ga328.png](https://s2.ax1x.com/2020/02/24/3Ga328.png)  
此时，箭头会创建多个线程，使array中的每一个元素都“同时”作为下一个图的参数执行，这里的同时加了引号，因为这个同时是宏观上的同时，它们在不同线程上执行，但是在实际上，它们会有微小的时间差。可以近似的理解为下面这张图  
![3Gdq6U.png](https://s2.ax1x.com/2020/02/24/3Gdq6U.png)  
那输出结果就很明显了，会将每个元素都输出，但是因为多线程执行顺序的不确定，所以输出的顺序也会不一定。  
![3GwFXD.png](https://s2.ax1x.com/2020/02/24/3GwFXD.png)  
另外需要补充一点，如果一个数组push箭头是foreach的话，还可以通过pop箭头回到原图，回原图的时候回重新构建数组。

### 4.2.4 结构化  
结构化类型的箭头，会将箭头开始的节点中所有的变量装进一个结构体中，拷贝到“目标”，来举个栗子  
![3G0M5R.png](https://s2.ax1x.com/2020/02/24/3G0M5R.png)  
这个例子中在state节点中定义了三个变量，然后使用结构化箭头传递到print图中  
![3G0UVH.png](https://s2.ax1x.com/2020/02/24/3G0UVH.png)  
在使用结构化箭头的时候，源是不需要指定的，因为会将所有的变量都传递过去  
![3G06sS.png](https://s2.ax1x.com/2020/02/24/3G06sS.png)  
将所有变量打包成了一个结构体，这个就是结构化箭头的作用。

## 4.3 引用  
引用等同于指针，在4.2.1中，我们发现了在箭头将数据拷贝过去以后，改变拷贝过去以后的数据并不会导致源数据被改变，那么如果我们用上引用，结果将会完全不一样  
![3GyVHS.png](https://s2.ax1x.com/2020/02/24/3GyVHS.png)  
稍微改造了一下，将testHelp中的print节点删除了，而在state中进行了输出  
![3Gylj0.png](https://s2.ax1x.com/2020/02/24/3Gylj0.png)  
来看看结果  
![3GyGHU.png](https://s2.ax1x.com/2020/02/24/3GyGHU.png)  
可以看到，改变目标数据，源数据也同样被改变了。因为引用等同于指针，它们操作的都是同一块内存空间。

## 4.4 并发  
PIG就是为并发而生，有两种并行的方法，一种是当有多个箭头，且箭头的期望值相同的时候，就会多个箭头方向同时执行，如4.2.1中的例子；另一种方法就是foreach，使用foreach箭头的时候，会创建多个线程，如4.2.3中的例子。

<h1>第五章 数据库</h1>
PIG使用的DBMS是sqlLite，并对库、表、字段等概念进行了封装，用户只要指定表名、设置数据字段就可以轻松操作数据库！
## 5.1 数据库基础  
数据库归根结底有四种操作、


   
<h1>第六章 实例</h1>  
## 6.1 简单的网页  
我们直接来做一个很简单的网站。首先，我们新建一个图，并添加两个节点，一个“start”表示开始，一个“end”表示结束，在其中建立start到end的箭头，注意，需要在end节点中写一点代码  
![3B7zrj.png](https://s2.ax1x.com/2020/02/28/3B7zrj.png)  
接下来，我们在“website”文件夹下创建一个“pages”文件夹，并在里面建一个“test1.html”文件，内容如下  
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>hello world</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
</head>
<body>
	<div id="hello"></div>
</body>
<script>
    $(()=>{
        $.ajax({
            type: "post",
            url: "/mgrApi?startPointId=6E980EF9-04B7-4b69-B648-6BDBCA2D3241",
            contentType: "application/json;charset=utf-8",
            dataType : "json",
            data:JSON.stringify({name:"yd",pwd:"123456"}),
            success: function (result) {
                $("#hello").html(result.data.model.hello);
            }
        });
    });
</script>
</html>
```
需要注意的是其中的startPointId是我们创建的start节点的id，可以在属性中看到  
![3D5TJS.png](https://s2.ax1x.com/2020/02/28/3D5TJS.png)  
![3D5xoV.png](https://s2.ax1x.com/2020/02/28/3D5xoV.png)  
准备就绪，打开我们的网页，就能见到结果了！  
![3DImFK.png](https://s2.ax1x.com/2020/02/28/3DImFK.png)

## 6.2从数据库读取数据的网页  
上一节我们打通了网页和PIG程序的交互，这一节我们来看下网页怎么从PIG的数据库中取出数据，在开始之前，我们先准备一条数据，在“数据”选项卡中插入一条数据  
![3D7jcF.png](https://s2.ax1x.com/2020/02/28/3D7jcF.png)    
网页与上一节一样，我们需要改变的是PIG程序  
![3D7h6g.png](https://s2.ax1x.com/2020/02/28/3D7h6g.png)  
其中需要注意两个跨图的箭头，“start”节点到listdata图为push箭头，需要映射一个resTypeId参数  
![3DHVje.png](https://s2.ax1x.com/2020/02/28/3DHVje.png)  
而listdata图回到“end”节点的箭头为pop箭头，需要对应push箭头  
![3DHsvF.png](https://s2.ax1x.com/2020/02/28/3DHsvF.png)  
映射一个list回来  
![3DH6u4.png](https://s2.ax1x.com/2020/02/28/3DH6u4.png)  
在“end”节点中的代码就需要稍微改一改了，我们通过箭头将list映射回来了，我们要拿到list的第0的元素，并将这个元素的name字段取出来赋值给model的“hello”  
![3DHRER.png](https://s2.ax1x.com/2020/02/28/3DHRER.png)  
完成这一步我们就可以打开网页刷新一下  
![3Dbe2T.png](https://s2.ax1x.com/2020/02/28/3Dbe2T.png)  
complete！

